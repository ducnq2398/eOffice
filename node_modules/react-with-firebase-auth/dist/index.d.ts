import React from 'react';
import firebase from 'firebase';
export declare type WrappedComponentProps = {
    signInWithEmailAndPassword: (email: string, password: string) => void;
    createUserWithEmailAndPassword: (email: string, password: string) => void;
    signInWithGoogle: () => void;
    signInWithFacebook: () => void;
    signInWithGithub: () => void;
    signInWithTwitter: () => void;
    signInWithPhoneNumber: (phoneNumber: string, applicationVerifier: firebase.auth.ApplicationVerifier) => void;
    signInAnonymously: () => void;
    signOut: () => void;
    setError: (error: string) => void;
    user?: firebase.User | null;
    error?: string;
    loading: boolean;
};
export declare type PossibleProviders = keyof ProvidersMapper;
export declare type ProvidersMapper = {
    googleProvider?: firebase.auth.GithubAuthProvider_Instance;
    facebookProvider?: firebase.auth.FacebookAuthProvider_Instance;
    twitterProvider?: firebase.auth.TwitterAuthProvider_Instance;
    githubProvider?: firebase.auth.GithubAuthProvider_Instance;
};
export declare type HocParameters = {
    firebaseAppAuth: firebase.auth.Auth;
    providers?: ProvidersMapper;
};
export declare type FirebaseAuthProviderState = {
    loading: boolean;
    user?: firebase.User | null;
    error?: string;
};
declare const withFirebaseAuth: <P extends object>({ firebaseAppAuth, providers, }: HocParameters) => (WrappedComponent: React.ComponentType<P & WrappedComponentProps>) => {
    new (props: Readonly<P>): {
        state: {
            loading: boolean;
            user: undefined;
            error: undefined;
        };
        unsubscribeAuthStateListener: firebase.Unsubscribe;
        componentDidMount(): void;
        componentWillUnmount(): void;
        setError: (error: string) => void;
        toggleLoading: () => void;
        tryTo<T>(operation: () => Promise<T>): Promise<firebase.auth.Error | T>;
        tryToSignInWithProvider: (provider: "googleProvider" | "facebookProvider" | "twitterProvider" | "githubProvider") => Promise<firebase.auth.Error | firebase.auth.UserCredential>;
        signOut: () => void;
        signInAnonymously: () => void;
        signInWithGithub: () => void;
        signInWithTwitter: () => void;
        signInWithGoogle: () => void;
        signInWithFacebook: () => void;
        signInWithEmailAndPassword: (email: string, password: string) => void;
        signInWithPhoneNumber: (phoneNumber: string, applicationVerifier: firebase.auth.ApplicationVerifier) => void;
        createUserWithEmailAndPassword: (email: string, password: string) => void;
        sharedHandlers: {
            createUserWithEmailAndPassword: (email: string, password: string) => void;
            signInWithEmailAndPassword: (email: string, password: string) => void;
            signInWithGithub: () => void;
            signInWithTwitter: () => void;
            signInWithGoogle: () => void;
            signInWithFacebook: () => void;
            signInWithPhoneNumber: (phoneNumber: string, applicationVerifier: firebase.auth.ApplicationVerifier) => void;
            signInAnonymously: () => void;
            setError: (error: string) => void;
            signOut: () => void;
        };
        render(): JSX.Element;
        context: any;
        setState<K extends "loading" | "user" | "error">(state: FirebaseAuthProviderState | ((prevState: Readonly<FirebaseAuthProviderState>, props: Readonly<P>) => FirebaseAuthProviderState | Pick<FirebaseAuthProviderState, K> | null) | Pick<FirebaseAuthProviderState, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<P> & Readonly<{
            children?: React.ReactNode;
        }>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<P>, nextState: Readonly<FirebaseAuthProviderState>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<P>, prevState: Readonly<FirebaseAuthProviderState>): any;
        componentDidUpdate?(prevProps: Readonly<P>, prevState: Readonly<FirebaseAuthProviderState>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<FirebaseAuthProviderState>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<FirebaseAuthProviderState>, nextContext: any): void;
    };
    new (props: P, context?: any): {
        state: {
            loading: boolean;
            user: undefined;
            error: undefined;
        };
        unsubscribeAuthStateListener: firebase.Unsubscribe;
        componentDidMount(): void;
        componentWillUnmount(): void;
        setError: (error: string) => void;
        toggleLoading: () => void;
        tryTo<T>(operation: () => Promise<T>): Promise<firebase.auth.Error | T>;
        tryToSignInWithProvider: (provider: "googleProvider" | "facebookProvider" | "twitterProvider" | "githubProvider") => Promise<firebase.auth.Error | firebase.auth.UserCredential>;
        signOut: () => void;
        signInAnonymously: () => void;
        signInWithGithub: () => void;
        signInWithTwitter: () => void;
        signInWithGoogle: () => void;
        signInWithFacebook: () => void;
        signInWithEmailAndPassword: (email: string, password: string) => void;
        signInWithPhoneNumber: (phoneNumber: string, applicationVerifier: firebase.auth.ApplicationVerifier) => void;
        createUserWithEmailAndPassword: (email: string, password: string) => void;
        sharedHandlers: {
            createUserWithEmailAndPassword: (email: string, password: string) => void;
            signInWithEmailAndPassword: (email: string, password: string) => void;
            signInWithGithub: () => void;
            signInWithTwitter: () => void;
            signInWithGoogle: () => void;
            signInWithFacebook: () => void;
            signInWithPhoneNumber: (phoneNumber: string, applicationVerifier: firebase.auth.ApplicationVerifier) => void;
            signInAnonymously: () => void;
            setError: (error: string) => void;
            signOut: () => void;
        };
        render(): JSX.Element;
        context: any;
        setState<K extends "loading" | "user" | "error">(state: FirebaseAuthProviderState | ((prevState: Readonly<FirebaseAuthProviderState>, props: Readonly<P>) => FirebaseAuthProviderState | Pick<FirebaseAuthProviderState, K> | null) | Pick<FirebaseAuthProviderState, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<P> & Readonly<{
            children?: React.ReactNode;
        }>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<P>, nextState: Readonly<FirebaseAuthProviderState>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<P>, prevState: Readonly<FirebaseAuthProviderState>): any;
        componentDidUpdate?(prevProps: Readonly<P>, prevState: Readonly<FirebaseAuthProviderState>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<FirebaseAuthProviderState>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<FirebaseAuthProviderState>, nextContext: any): void;
    };
    displayName: string;
    contextType?: React.Context<any> | undefined;
};
export default withFirebaseAuth;
